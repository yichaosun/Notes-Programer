题目链接：https://leetcode-cn.com/problems/n-queens/

> n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```
示例: 输入: 4
输出: [
[".Q..",  // 解法 1
"...Q",
"Q...",
"..Q."],

["..Q.",  // 解法 2
"Q...",
"...Q",
".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```
```java
class Solution{
	private List<List<String>> result = new ArrayList<List<String>>();
	public List<List<String>> solveQueen(int target){
		int[] queen = new int[target];
		Arrays.fill(queen,"-1");
		Set<Integer> columns = new HashSet<Integer>();
		Set<Integer> diagonals1 = new HashSet<Integer>();
		Set<Integer> diagonals2 = new HashSet<Integer>();
		
		dsf(queen,0,columns,diagonals1,diagonals2);
		return result;
	}
	
	protected void dsf(int[] queen,int row,Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2){
		if(queen.length == row){
			result.add(generateBoard(queen));
			return;
		}
		for(int i=0; i<queen.length; i++){
			if(columns.contains(i){
				continue;
			}
			int diagonal1 = row+i;
			if(diagonals.contains(diagonal1)){
				contiune;
			}
			int diagonal2 = row-i;
			if(diagonals2.contains(diagonal2)){
				contiune;
			}
			queen[row] = i;
			columns.add(i);
			diagonals1.add(diagonal1);
			diagonals2.add(diagonal2);
			dfs(queen,row+1,columns,diagonals1,diagonals2);
			queen[row] = -1;
			columsn.remove(i);
			diagonals1.remove(diagonal1);
			diagonals2.remove(diagonal2);
		}
	}
	protected List<String> generateBoard(int[] queen){
		List<String> board= new ArrayList<Stirng>();
		for(int i =0;i<queen.length;i++){
			char[] row = new char[queen.length];
			Arrays.fill(row,'.');
			row[queen[i]] = 'Q';
			board.add(new String(row));
		}
		return board;
	}
}
```


